
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // =================================
    // Helper Functions
    // =================================

    function isSignedIn() {
      return request.auth != null;
    }

    function isUser(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    function isAdmin() {
      // Check for the admin custom claim on the auth token first for efficiency.
      // Fallback to checking the user document's role field.
      return isSignedIn() && (request.auth.token.admin == true || get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin');
    }
    
    function isOwnerOrAdmin(userId) {
      return isUser(userId) || isAdmin();
    }

    // =================================
    // Schema Validation Functions
    // =================================
    
    function isValidUser(data) {
      return data.name is string &&
             data.email is string &&
             data.balance is number &&
             data.adBalance is number &&
             data.totalSpent is number &&
             data.rank is string &&
             data.apiKey is string &&
             data.referralCode is string &&
             data.createdAt is string;
    }

    function canUpdateUserProfile(requestData, resourceData) {
        // User can only update these specific fields.
        let allowedFields = ['name', 'avatarUrl', 'notificationPreferences'];
        // Admins can update any field.
        return (isUser(request.auth.uid) && requestData.keys().hasOnly(allowedFields)) || isAdmin();
    }
    
    function isValidService(data) {
        return data.platform is string &&
               data.category is string &&
               data.price is number &&
               data.min is number &&
               data.max is number;
    }
    
    function isValidOrder(data) {
      return data.userId == request.auth.uid &&
             data.serviceId is string &&
             data.serviceName is string &&
             data.link is string &&
             data.quantity is number &&
             data.charge is number &&
             data.orderDate is string &&
             data.status in ['مكتمل', 'قيد التنفيذ', 'ملغي', 'جزئي'];
    }

    function isValidCampaign(data) {
        return data.userId == request.auth.uid &&
               data.name is string &&
               data.platform is string &&
               data.goal is string &&
               data.targetAudience is string &&
               data.startDate is string &&
               data.budget is number &&
               data.durationDays is number &&
               data.spend is number && data.spend == 0 && // Spend must be 0 on creation
               data.status == 'بانتظار المراجعة'; // Must be pending review on creation
    }

    function isValidDeposit(data) {
      return data.userId == request.auth.uid &&
             data.amount is number && data.amount > 0 &&
             data.paymentMethod is string &&
             data.depositDate is string &&
             data.status == 'معلق' && // Status must be pending on creation
             data.details is map;
    }
    
    function isValidTicket(data) {
      return data.userId == request.auth.uid &&
             data.subject is string &&
             data.message is string &&
             data.status == 'مفتوحة' && // Status must be open on creation
             data.createdDate is string &&
             data.messages.size() == 1; // Only the initial message is allowed on creation
    }


    // =================================
    // Collection Rules
    // =================================

    match /users/{userId} {
      allow read: if isOwnerOrAdmin(userId);
      
      // A user can create their own user document on signup.
      // The document must be valid and they cannot assign themselves as admin.
      allow create: if isUser(userId) && isValidUser(request.resource.data) && request.resource.data.role == 'user';
      
      // Users can update a limited set of their own fields. Admins can update anything.
      allow update: if (isUser(userId) && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['name', 'avatarUrl', 'notificationPreferences']))
                    || isAdmin();

      // Only admins can delete user accounts.
      allow delete: if isAdmin();
    }
    
    match /services/{serviceId} {
      allow read: if true; // Services are public
      allow write: if isAdmin(); // Only admins can create, update, delete services
    }
    
    match /blogPosts/{blogPostId} {
      allow read: if true; // Blog posts are public
      allow write: if isAdmin(); // Only admins can manage blog posts
    }

    match /systemLogs/{logId} {
      allow read, write: if isAdmin(); // Only admins can manage system logs
    }

    // Subcollection rules using a wildcard to cover Orders, Campaigns, etc.
    match /users/{userId}/{collectionName}/{docId} {
      allow read, delete: if isOwnerOrAdmin(userId);
      
      // CREATE: User creating their own valid subcollection document.
      allow create: if isUser(userId) && (
        (collectionName == 'orders' && isValidOrder(request.resource.data)) ||
        (collectionName == 'campaigns' && isValidCampaign(request.resource.data)) ||
        (collectionName == 'deposits' && isValidDeposit(request.resource.data)) ||
        (collectionName == 'tickets' && isValidTicket(request.resource.data)) ||
        // Add other subcollections here as needed
        (collectionName == 'withdrawals' || collectionName == 'agencyAccounts' || collectionName == 'affiliateTransactions') // More generic rule for others
      );

      // UPDATE: User can update their own docs, Admins can update any.
      allow update: if isOwnerOrAdmin(userId);
    }
  }
}
